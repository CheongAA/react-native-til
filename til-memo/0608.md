## 0. npm i 에러

```jsx
npm ERR! code ERESOLVE
npm ERR! ERESOLVE unable to resolve dependency tree
npm ERR! 
npm ERR! 
npm ERR! Could not resolve dependency:
npm ERR! dev babel-plugin-styled-components@"^1.12.0" from the root project
npm ERR! 
npm ERR! Conflicting peer dependency: styled-components@5.3.0
npm ERR! node_modules/styled-components
npm ERR!   styled-components@"^5.3.0" from the root project
npm ERR!   peer styled-components@">= 2" from babel-plugin-styled-components@1.12.0
npm ERR!   node_modules/babel-plugin-styled-components
npm ERR!     dev babel-plugin-styled-components@"^1.12.0" from the root project
npm ERR!     babel-plugin-styled-components@">= 1.12.0" from styled-components@5.3.0
npm ERR! 
npm ERR! Fix the upstream dependency conflict, or retry
npm ERR! this command with --force, or --legacy-peer-deps
npm ERR! to accept an incorrect (and potentially broken) dependency resolution.
npm ERR! 
npm ERR! See /Users/cheongaakim/.npm/eresolve-report.txt for a full report.

npm ERR! A complete log of this run can be found in:
npm ERR!     /Users/cheongaakim/.npm/_logs/2021-06-08T07_20_45_952Z-debug.log
```

- npm install 시 에러발생
- 충돌이 일어난 모듈의 버전을 낮추거나, --legacy-peer-deps 명령어로 install 하면 해결가능

### 1. M1 이슈

react-native init 으로 프로젝트 생성 후 빌드시 빌드 에러 발생시 해결방법

[iOS]

./iOS/Podfile : 하단 소스 주석처리

```jsx
#use_flipper!()

#post_install do |installer|
# react_native_post_install(installer)
#end
```

빌드 파일 삭제 후 재실행

```jsx
cd ios

rm -rf build

pod install

cd ..

npm run iOS
```

[android]

m1 전용 애뮬레이터 설치 후 재실행

[https://github.com/741g/android-emulator-m1-preview/releases](https://github.com/741g/android-emulator-m1-preview/releases) 

## 2. Styled-Components

리액트 네이티브의 스타일을 적용하는 방법

- 인라인
- stylesheet
- styled-components

styled-components의 장점

- 리액트와 리액트 네이티브에 동일한 스타일 코드 적용 가능
- 리액트 네이티브의 스타일은 오브젝트 형식을 사용하기 때문에 css를 카멜표기법으로 작성해야한다 → styled-components를 이용하면 기존과 동일 방식으로 css 표기 가능
- 동적으로 변경되는 스타일의 관리가 쉬워짐

styled-components의 단점

- 빌드 후 재배포 시 파일 용량이 커짐

## 3. Props와 State

Props

- 부모 컴포넌트로부터 자식 컴포넌트로 전달되는 데이터
- 자식 컴포넌트에서는 변경이 불가능

State

- 한 컴포넌트 안에서 유동적인 데이터를 다룰 때 사용
- 컴포넌트 안에서 변경 가능
- set 함수를 통해 state를 변경할 수 있는데 직접 변경하지 않고 set 함수를 사용하는 이유는 변수값을 직접 변경하면서 발생할 수 있는 오류를 줄이고, 리액트의 가상 돔을 활용하여 변경된 부분만 화면을 갱신하기 위함이다.

## 4. class component

- 리액트 훅이 나오면서 함수형 컴포넌트가 메인으로 사용되기 시작했지만, 아직도 많은 라이브러리, 예제 소스들이 클래스 컴포넌트로 되어있기 때문에 class component를 이해하는 것도 중요하다.
- 클래스 컴포넌트에서는 생성자 함수에서 state 초기값을 설정한다.
- 생성자는 항상 super(props);를 사용하여 부모 컴포넌트의 생성자 함수를 호출한다.
- 클래스 컴포넌트응 여러 라이프 사이클 함수를 가지고 있다.
- state에 접근하기 위해서는 this.state를 사용하고, 변경하기 위해서는 this.setState를 사용한다.

## 5. class component lifecycle

- constructor 함수: 컴포넌트가 생성될 때 한 번만 호출
- render 함수: props, state 값이 변경되어 화면을 갱신할 때 마다 호출 (render에서 setState 호출 시 무한 루프에 빠질 수 있음)
- getDerivedStateFromProps 함수: 컴포넌트가 생성될 때 한 번 호출되고, props가 변경될 때 마다 호출된다. 부모로부터 받은 props와 state를 동기화 할 때 사용
- componentDidMount 함수: 처음 render 함수 호출 이후 호출됨
- shouldComponentUpdate 함수: 이 함수에서 false를 반환하면 리렌더링을 방지할 수 있다. 잘 이용하면 성능이 좋은 앱 제작 가능
- getSnapshotBeforeUpdate 함수: render 함수 호출 후 실제 화면이 갱신되기 직전에 호출된다.
- componentDidUpdate 함수: componentDidMount가 처음 화면에 표시된 후 다시 호출되지 않는 함수인 반면에 이 함수는 처음 화면에 표시될 때 호출되지 않지만 props,state가 변경되어 화면이 갱신될 때 마다 render 이후에 호출됨
- componentWillUnmount 함수: 해당 컴포넌트가 화면에서 완전히 사라질 때 호출되는 함수
- componentDidCatch 함수: 에러 발생 시 호출

## 6. Image

Image를 저장할 때 이미지명은 add, add@2, add@3 이런식으로 저장하면 배율에 따라서 해당 이미지가 설정된다.